"""
Сервис для генерации шаблонов отчетов.
"""
import pandas as pd
import io
from pathlib import Path
from typing import Tuple


def generate_objects_template() -> Tuple[bytes, str]:
    """
    Генерирует шаблон CSV для файла Objects.
    
    Returns:
        Tuple[bytes, str]: (CSV данные, имя файла)
    """
    # Определяем колонки с примерами
    template_data = {
        'object_id': [1, 2, 3],
        'object_name': [
            'Участок-001', 
            'Участок-002', 
            'Кран-003'
        ],
        'object_type': [
            'pipeline_section', 
            'pipeline_section', 
            'crane'
        ],
        'pipeline_id': [
            'MT-01', 
            'MT-01', 
            'MT-02'
        ],
        'lat': [48.476357, 48.480000, 48.490000],
        'lon': [57.660536, 57.670000, 57.680000],
        'year': [2010, 2012, 2015],
        'material': ['Сталь', 'Сталь', 'Сталь']
    }
    
    df = pd.DataFrame(template_data)
    
    # Конвертируем в CSV с правильной кодировкой
    output = io.StringIO()
    df.to_csv(output, index=False, encoding='utf-8-sig')  # UTF-8 с BOM для Excel
    csv_content = output.getvalue()
    
    return csv_content.encode('utf-8-sig'), 'Objects_template.csv'


def generate_diagnostics_template() -> Tuple[bytes, str]:
    """
    Генерирует шаблон CSV для файла Diagnostics.
    Структурирован для лучшего понимания ML и AI.
    Содержит детальные примеры описаний дефектов для точного анализа.
    
    Returns:
        Tuple[bytes, str]: (CSV данные, имя файла)
    """
    # Определяем колонки с примерами и инструкциями
    # Примеры структурированы для лучшего понимания ML и AI
    template_data = {
        'diag_id': [1, 2, 3, 4, 5],
        'object_id': [1, 1, 2, 2, 3],
        'method': [
            'VIK',      # Визуальный контроль
            'MFL',      # Магнитопорошковый контроль
            'UTWM',     # Ультразвуковой контроль толщины стенки
            'VIK', 
            'EC'        # Электромагнитный контроль
        ],
        'date': [
            '2025-01-15',
            '2025-01-15',
            '2025-01-16',
            '2025-01-16',
            '2025-01-17'
        ],
        'defect_found': [True, True, False, True, False],
        'defect_description': [
            # Пример 1: ДЕТАЛЬНОЕ описание для высокого риска (ВАЖНО для AI!)
            'Глубокая коррозия глубиной 25.5 мм на участке трубопровода 10-15 метров от точки отсчета. Площадь дефекта 150 см². Трещина сквозная в нескольких местах. Требуется немедленный ремонт. Критическое состояние.',
            # Пример 2: Средний риск с конкретными параметрами
            'Обнаружена аномалия магнитного поля. Глубина аномалии 15 мм, ширина 30 мм, длина 50 м. Возможная трещина в сварном шве. Требуется дополнительное обследование и планирование ремонта.',
            # Пример 3: Норма - без дефектов
            'Дефектов не обнаружено. Состояние удовлетворительное. Толщина стенки в пределах нормы.',
            # Пример 4: Поверхностная коррозия
            'Поверхностная коррозия глубиной 8.5 мм на площади 45 см², длина участка 20 м. Не требует срочного ремонта. Рекомендуется мониторинг.',
            # Пример 5: Норма
            'Дефектов не обнаружено. Все параметры в пределах нормы.'
        ],
        'param1': [25.5, 15.0, None, 8.5, None],  # Глубина (мм), аномалия (%), толщина (мм), глубина (мм), None
        'param2': [150.0, 30.0, None, 45.0, None],  # Площадь (см²), ширина (мм), None, площадь (см²), None
        'param3': [12.5, 50.0, None, 20.0, None],  # Длина (м), длина (м), None, длина (м), None
        'temperature': [15.0, 18.0, 20.0, 16.0, 17.0],  # Температура воздуха (°C)
        'humidity': [65.0, 70.0, 60.0, 68.0, 62.0],  # Влажность (%)
        'illumination': [500.0, 600.0, 550.0, 580.0, 520.0],  # Освещенность (лк)
        'quality_grade': [
            'недопустимо',  # Критический дефект
            'допустимо',    # Средний риск
            'удовлетворительно',  # Норма
            'допустимо',
            'удовлетворительно'
        ],
        'ml_label': [
            'high',      # Высокий риск - система автоматически определит
            'medium',    # Средний риск
            'normal',    # Норма (можно оставить пустым - система определит)
            'medium',
            'normal'
        ]
    }
    
    df = pd.DataFrame(template_data)
    
    # Конвертируем в CSV с правильной кодировкой
    output = io.StringIO()
    df.to_csv(output, index=False, encoding='utf-8-sig')  # UTF-8 с BOM для Excel
    csv_content = output.getvalue()
    
    return csv_content.encode('utf-8-sig'), 'Diagnostics_template.csv'


def generate_template_with_instructions(file_type: str) -> Tuple[bytes, str]:
    """
    Генерирует шаблон с инструкциями в виде комментариев.
    
    Args:
        file_type: 'objects' или 'diagnostics'
        
    Returns:
        Tuple[bytes, str]: (CSV данные, имя файла)
    """
    if file_type == 'objects':
        # Создаем CSV с инструкциями в первой строке
        instructions = [
            '# ШАБЛОН ОТЧЕТА: ОБЪЕКТЫ (EQUIPMENT)',
            '# Инструкция:',
            '# - object_id: Уникальный ID объекта (целое число)',
            '# - object_name: Название объекта (текст)',
            '# - object_type: Тип объекта - crane, compressor или pipeline_section',
            '# - pipeline_id: ID трубопровода (например: MT-01, MT-02, HACK-01)',
            '# - lat: Широта в градусах (число с точкой, например: 48.476357)',
            '# - lon: Долгота в градусах (число с точкой, например: 57.660536)',
            '# - year: Год постройки объекта (целое число, опционально)',
            '# - material: Материал объекта (текст, опционально)',
            '#',
        ]
    else:  # diagnostics
        instructions = [
            '# ШАБЛОН ОТЧЕТА: ДИАГНОСТИКА',
            '# Инструкция для ML и AI:',
            '# - diag_id: Уникальный ID диагностики (целое число)',
            '# - object_id: ID объекта из файла Objects (ссылка на object_id)',
            '# - method: Метод диагностики - VIK, MFL, UTWM, UT, EC, PVK, MPK, UZK, RGK, TVK, VIBRO, TFI, GEO',
            '# - date: Дата диагностики в формате YYYY-MM-DD',
            '# - defect_found: Найден ли дефект - true или false',
            '# - defect_description: ДЕТАЛЬНОЕ описание дефекта (ВАЖНО для AI анализа):',
            '#   * Указывайте: тип дефекта, локацию, размеры, критичность',
            '#   * Примеры: "Глубокая коррозия 25мм на участке 10-15м", "Трещина сквозная 50мм"',
            '#   * Для ML важно использовать ключевые слова: критический, аварийный, глубокая, поверхностная',
            '# - param1: Параметр 1 - зависит от метода (число с точкой):',
            '#   * VIK: глубина дефекта (мм)',
            '#   * MFL: глубина аномалии (мм)',
            '#   * UTWM: толщина стенки (мм)',
            '#   * VIBRO: виброскорость (мм/с)',
            '# - param2: Параметр 2 - зависит от метода (число с точкой):',
            '#   * VIK/MFL: площадь/ширина дефекта (см²/мм)',
            '#   * UTWM: потеря толщины (%)',
            '# - param3: Параметр 3 - дополнительный параметр (число с точкой или пусто)',
            '# - temperature: Температура воздуха при диагностике (°C, опционально)',
            '# - humidity: Влажность воздуха при диагностике (%, опционально)',
            '# - illumination: Освещенность при диагностике (лк, опционально)',
            '# - quality_grade: Оценка качества - удовлетворительно, допустимо, недопустимо (опционально)',
            '# - ml_label: Метка критичности - normal, medium, high (опционально, система определит автоматически)',
            '#',
            '# ВАЖНО для ML:',
            '# - Чем детальнее defect_description, тем точнее анализ AI',
            '# - Заполняйте param1, param2, param3 - они используются для предсказания',
            '# - Если ml_label пусто, система автоматически определит критичность',
            '#',
        ]
    
    # Получаем данные шаблона
    if file_type == 'objects':
        data_bytes, filename = generate_objects_template()
    else:
        data_bytes, filename = generate_diagnostics_template()
    
    # Объединяем инструкции с данными
    instructions_text = '\n'.join(instructions)
    data_text = data_bytes.decode('utf-8-sig')
    
    # Некоторые CSV парсеры не понимают комментарии, создаем отдельный README
    # Для CSV оставляем только данные, инструкции будут в отдельном файле
    return data_bytes, filename

